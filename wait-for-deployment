#!/bin/bash
# Waits for a deployment to complete.
#
# Includes a two-step approach:
#
# 1. Wait for the observed generation to match the specified one.
# 2. Waits for the number of available replicas to match the specified one.
#
# Spawn from my answer to this StackOverflow question: http://stackoverflow.com/questions/37448357/ensure-kubernetes-deployment-has-completed-and-all-pods-are-updated-and-availabl
#
set -o errexit
set -o pipefail

DEFAULT_TIMEOUT=60

monitor_timeout() {
  sleep ${timeout}
  echo "Timeout ${timeout} exceeded" >&2
  kill $1
}

get_generation() {
  get_deployment_jsonpath '{.metadata.generation}'
}

get_observed_generation() {
  get_deployment_jsonpath '{.status.observedGeneration}'
}

get_replicas() {
  get_deployment_jsonpath '{.spec.replicas}'
}

get_available_replicas() {
  get_deployment_jsonpath '{.status.availableReplicas}'
}

get_deployment_jsonpath() {
  local -r jsonpath="$1"

  kubectl get deployment "${deployment}" -o "jsonpath=${jsonpath}"
}

if [[ $# -lt 1 ]]; then
  echo "usage: $(basename $0) <deployment> [timeout]" >&2
  exit 1
fi

if [[ $2 -gt 0 ]]; then
  export timeout=$2
else 
  export timeout=$DEFAULT_TIMEOUT
fi

echo "Waiting for deployment with timeout: ${timeout} seconds"

monitor_timeout $$ &
readonly timeout_monitor_pid=$!

readonly deployment="$1"

generation=$(get_generation); readonly generation
echo "waiting for specified generation ${generation} to be observed"
while [[ $(get_observed_generation) -lt ${generation} ]]; do
  sleep .5
done
echo "specified generation observed."

replicas="$(get_replicas)"; readonly replicas
echo "specified replicas: ${replicas}"

available=-1
while [[ ${available} -ne ${replicas} ]]; do
  sleep .5
  available=$(get_available_replicas)
  echo "available replicas: ${available}"
done

kill ${timeout_monitor_pid} #Stop timeout monitor
echo "deployment complete."
